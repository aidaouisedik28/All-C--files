using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace UnovaMemory
{
    public class UnovaMem
    {
        #region WinAPI Imports
        [DllImport("kernel32.dll")]
        private static extern void GetSystemInfo(out SYSTEM_INFO lpSystemInfo);
        
        [DllImport("kernel32.dll")]
        public static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);
        
        [DllImport("kernel32")]
        public static extern bool IsWow64Process(IntPtr hProcess, out bool lpSystemInfo);
        
        [DllImport("kernel32.dll")]
        private static extern bool VirtualProtectEx(IntPtr hProcess, UIntPtr lpAddress, IntPtr dwSize, 
            MemoryProtection flNewProtect, out MemoryProtection lpflOldProtect);
        
        [DllImport("kernel32.dll")]
        private static extern bool WriteProcessMemory(IntPtr hProcess, UIntPtr lpBaseAddress, byte[] lpBuffer, 
            UIntPtr nSize, IntPtr lpNumberOfBytesWritten);
        
        [DllImport("kernel32.dll")]
        private static extern bool ReadProcessMemory(IntPtr hProcess, UIntPtr lpBaseAddress, [Out] byte[] lpBuffer, 
            UIntPtr nSize, IntPtr lpNumberOfBytesRead);
        
        [DllImport("kernel32.dll")]
        private static extern bool ReadProcessMemory(IntPtr hProcess, UIntPtr lpBaseAddress, [Out] IntPtr lpBuffer, 
            UIntPtr nSize, out ulong lpNumberOfBytesRead);
        
        [DllImport("kernel32.dll")]
        public static extern int CloseHandle(IntPtr hObject);
        
        [DllImport("kernel32.dll", EntryPoint = "VirtualQueryEx")]
        public static extern UIntPtr Native_VirtualQueryEx(IntPtr hProcess, UIntPtr lpAddress, 
            out MEMORY_BASIC_INFORMATION64 lpBuffer, UIntPtr dwLength);
        
        [DllImport("kernel32.dll", EntryPoint = "VirtualQueryEx")]
        public static extern UIntPtr Native_VirtualQueryEx(IntPtr hProcess, UIntPtr lpAddress, 
            out MEMORY_BASIC_INFORMATION32 lpBuffer, UIntPtr dwLength);
        
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
        private static extern uint GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, 
            StringBuilder lpReturnedString, uint nSize, string lpFileName);
        #endregion

        #region Fields
        private readonly Dictionary<string, IntPtr> _modules = new Dictionary<string, IntPtr>();
        private ProcessModule _mainModule;
        private Process _theProc;
        private IntPtr _pHandle;
        private bool _is64Bit;
        private const uint MEM_PRIVATE = 0x20000;
        private const uint MEM_IMAGE = 0x1000000;
        private const uint PROCESS_ALL_ACCESS = 0x1F0FFF;
        
        // Cache for parsed codes to avoid re-parsing
        private readonly ConcurrentDictionary<string, UIntPtr> _codeCache = new ConcurrentDictionary<string, UIntPtr>();
        #endregion

        #region Properties
        public bool Is64Bit => _is64Bit;
        public Process Process => _theProc;
        public IntPtr ProcessHandle => _pHandle;
        #endregion

        #region Process Management
        public bool OpenProcess(int pid)
        {
            if (!IsAdmin())
            {
                Debug.WriteLine("WARNING: Not running as administrator!");
            }

            if (pid <= 0)
            {
                Debug.WriteLine("ERROR: Invalid process ID.");
                return false;
            }

            if (_theProc?.Id == pid && _pHandle != IntPtr.Zero)
            {
                return true;
            }

            try
            {
                _theProc = Process.GetProcessById(pid);
                
                if (_theProc == null || !_theProc.Responding)
                {
                    Debug.WriteLine("ERROR: Process is not responding or null.");
                    return false;
                }

                _pHandle = OpenProcess(PROCESS_ALL_ACCESS, true, pid);
                
                if (_pHandle == IntPtr.Zero)
                {
                    Debug.WriteLine($"ERROR: Failed to open process handle (Error: {Marshal.GetLastWin32Error()})");
                    _theProc = null;
                    return false;
                }

                Process.EnterDebugMode();
                _mainModule = _theProc.MainModule;
                GetModules();
                
                bool isWow64;
                _is64Bit = Environment.Is64BitOperatingSystem && 
                          IsWow64Process(_pHandle, out isWow64) && !isWow64;

                Debug.WriteLine($"Process #{pid} opened successfully. Is64Bit: {_is64Bit}");
                return true;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR: Exception opening process: {ex.Message}");
                return false;
            }
        }

        public void CloseProcess()
        {
            if (_pHandle != IntPtr.Zero)
            {
                CloseHandle(_pHandle);
                _pHandle = IntPtr.Zero;
            }

            if (_theProc != null)
            {
                try
                {
                    Process.LeaveDebugMode();
                }
                catch { }
                
                _theProc = null;
            }

            _modules.Clear();
            _codeCache.Clear();
        }

        private void GetModules()
        {
            if (_theProc == null) return;

            _modules.Clear();
            
            try
            {
                foreach (ProcessModule module in _theProc.Modules)
                {
                    if (!string.IsNullOrEmpty(module.ModuleName) && !_modules.ContainsKey(module.ModuleName))
                    {
                        _modules.Add(module.ModuleName, module.BaseAddress);
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR: Failed to enumerate modules: {ex.Message}");
            }
        }
        #endregion

        #region Memory Reading
        public byte[] ReadBytes(string code, long length, string file = "")
        {
            byte[] buffer = new byte[length];
            UIntPtr address = GetCode(code, file);
            
            if (address == UIntPtr.Zero)
                return null;

            if (!ReadProcessMemory(_pHandle, address, buffer, (UIntPtr)(ulong)length, IntPtr.Zero))
                return null;

            return buffer;
        }

        public T ReadMemory<T>(string code, string file = "") where T : struct
        {
            int size = Marshal.SizeOf<T>();
            byte[] buffer = ReadBytes(code, size, file);
            
            if (buffer == null)
                return default(T);

            GCHandle handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            try
            {
                return Marshal.PtrToStructure<T>(handle.AddrOfPinnedObject());
            }
            finally
            {
                handle.Free();
            }
        }
        #endregion

        #region Memory Writing
        public bool WriteMemory(string code, string type, string write, string file = "", Encoding stringEncoding = null)
        {
            byte[] data;
            int size;

            switch (type.ToLower())
            {
                case "float":
                    data = BitConverter.GetBytes(Convert.ToSingle(write));
                    size = 4;
                    break;
                    
                case "int":
                case "int32":
                    data = BitConverter.GetBytes(Convert.ToInt32(write));
                    size = 4;
                    break;
                    
                case "long":
                case "int64":
                    data = BitConverter.GetBytes(Convert.ToInt64(write));
                    size = 8;
                    break;
                    
                case "double":
                    data = BitConverter.GetBytes(Convert.ToDouble(write));
                    size = 8;
                    break;
                    
                case "byte":
                    data = new byte[] { Convert.ToByte(write, 16) };
                    size = 1;
                    break;
                    
                case "2bytes":
                    int val = Convert.ToInt32(write);
                    data = new byte[] { (byte)(val & 0xFF), (byte)((val >> 8) & 0xFF) };
                    size = 2;
                    break;
                    
                case "bytes":
                    data = ParseBytes(write);
                    size = data.Length;
                    break;
                    
                case "string":
                    data = (stringEncoding ?? Encoding.UTF8).GetBytes(write);
                    size = data.Length;
                    break;
                    
                default:
                    return false;
            }

            UIntPtr address = GetCode(code, file);
            if (address == UIntPtr.Zero)
                return false;

            return WriteProcessMemory(_pHandle, address, data, (UIntPtr)(ulong)size, IntPtr.Zero);
        }

        private byte[] ParseBytes(string byteString)
        {
            if (string.IsNullOrWhiteSpace(byteString))
                return new byte[0];

            char[] separators = { ',', ' ' };
            string[] parts = byteString.Split(separators, StringSplitOptions.RemoveEmptyEntries);
            
            byte[] result = new byte[parts.Length];
            for (int i = 0; i < parts.Length; i++)
            {
                result[i] = Convert.ToByte(parts[i].Trim(), 16);
            }
            
            return result;
        }
        #endregion

        #region Address Resolution
        public UIntPtr GetCode(string code, string file = "", int size = 8)
        {
            if (string.IsNullOrWhiteSpace(code))
                return UIntPtr.Zero;

            // Check cache first
            string cacheKey = $"{code}|{file}";
            if (_codeCache.TryGetValue(cacheKey, out UIntPtr cachedAddress))
                return cachedAddress;

            UIntPtr result = _is64Bit ? Get64BitCode(code, file, size == 8 ? 16 : size) 
                                      : Get32BitCode(code, file, size);

            // Cache the result
            _codeCache.TryAdd(cacheKey, result);
            
            return result;
        }

        private UIntPtr Get64BitCode(string code, string file, int size)
        {
            string address = !string.IsNullOrEmpty(file) ? LoadCode(code, file) : code;
            
            if (string.IsNullOrWhiteSpace(address))
                return UIntPtr.Zero;

            address = address.Replace(" ", "");

            // Direct address (no offsets)
            if (!address.Contains("+") && !address.Contains(","))
            {
                return new UIntPtr(Convert.ToUInt64(address, 16));
            }

            // Parse base and offsets
            string[] parts = address.Split('+');
            string basePart = parts[0];
            string offsetPart = parts.Length > 1 ? parts[1] : "";

            // Get base address
            IntPtr baseAddress = GetBaseAddress(basePart);
            if (baseAddress == IntPtr.Zero && !basePart.Contains("base") && !basePart.Contains("main"))
            {
                return UIntPtr.Zero;
            }

            // No pointer chain
            if (!offsetPart.Contains(','))
            {
                long offset = string.IsNullOrEmpty(offsetPart) ? 0 : Convert.ToInt64(offsetPart, 16);
                return new UIntPtr((ulong)((long)baseAddress + offset));
            }

            // Pointer chain
            long[] offsets = ParseOffsets(offsetPart);
            return ResolvePointerChain64(baseAddress, offsets, size);
        }

        private UIntPtr Get32BitCode(string code, string file, int size)
        {
            string address = !string.IsNullOrEmpty(file) ? LoadCode(code, file) : code;
            
            if (string.IsNullOrWhiteSpace(address))
                return UIntPtr.Zero;

            address = address.Replace(" ", "");

            if (!address.Contains("+") && !address.Contains(","))
            {
                return new UIntPtr(Convert.ToUInt32(address, 16));
            }

            string[] parts = address.Split('+');
            string basePart = parts[0];
            string offsetPart = parts.Length > 1 ? parts[1] : "";

            IntPtr baseAddress = GetBaseAddress(basePart);
            if (baseAddress == IntPtr.Zero && !basePart.Contains("base") && !basePart.Contains("main"))
            {
                return UIntPtr.Zero;
            }

            if (!offsetPart.Contains(','))
            {
                int offset = string.IsNullOrEmpty(offsetPart) ? 0 : Convert.ToInt32(offsetPart, 16);
                return new UIntPtr((uint)((int)baseAddress + offset));
            }

            long[] offsets = ParseOffsets(offsetPart);
            return ResolvePointerChain32(baseAddress, offsets, size);
        }

        private IntPtr GetBaseAddress(string basePart)
        {
            if (basePart.Contains("base") || basePart.Contains("main"))
            {
                return _mainModule?.BaseAddress ?? IntPtr.Zero;
            }

            if (basePart.EndsWith(".dll") || basePart.EndsWith(".exe") || basePart.EndsWith(".bin"))
            {
                return _modules.TryGetValue(basePart, out IntPtr moduleBase) ? moduleBase : IntPtr.Zero;
            }

            string cleaned = basePart.Replace("0x", "");
            return _is64Bit ? (IntPtr)long.Parse(cleaned, NumberStyles.HexNumber) 
                            : (IntPtr)int.Parse(cleaned, NumberStyles.HexNumber);
        }

        private long[] ParseOffsets(string offsetString)
        {
            string[] parts = offsetString.Split(',');
            long[] offsets = new long[parts.Length];

            for (int i = 0; i < parts.Length; i++)
            {
                string offset = parts[i].Replace("0x", "").Trim();
                bool isNegative = offset.StartsWith("-");
                
                if (isNegative)
                    offset = offset.Substring(1);

                offsets[i] = long.Parse(offset, NumberStyles.HexNumber);
                
                if (isNegative)
                    offsets[i] = -offsets[i];
            }

            return offsets;
        }

        private UIntPtr ResolvePointerChain64(IntPtr baseAddress, long[] offsets, int size)
        {
            byte[] buffer = new byte[size];
            long currentAddress = (long)baseAddress + offsets[0];

            if (!ReadProcessMemory(_pHandle, (UIntPtr)(ulong)currentAddress, buffer, (UIntPtr)(ulong)size, IntPtr.Zero))
                return UIntPtr.Zero;

            for (int i = 1; i < offsets.Length; i++)
            {
                currentAddress = BitConverter.ToInt64(buffer, 0) + offsets[i];
                
                if (!ReadProcessMemory(_pHandle, (UIntPtr)(ulong)currentAddress, buffer, (UIntPtr)(ulong)size, IntPtr.Zero))
                    return UIntPtr.Zero;
            }

            return (UIntPtr)(ulong)currentAddress;
        }

        private UIntPtr ResolvePointerChain32(IntPtr baseAddress, long[] offsets, int size)
        {
            byte[] buffer = new byte[size];
            uint currentAddress = (uint)((int)baseAddress + (int)offsets[0]);

            if (!ReadProcessMemory(_pHandle, (UIntPtr)currentAddress, buffer, (UIntPtr)(ulong)size, IntPtr.Zero))
                return UIntPtr.Zero;

            for (int i = 1; i < offsets.Length; i++)
            {
                currentAddress = BitConverter.ToUInt32(buffer, 0) + (uint)offsets[i];
                
                if (!ReadProcessMemory(_pHandle, (UIntPtr)currentAddress, buffer, (UIntPtr)(ulong)size, IntPtr.Zero))
                    return UIntPtr.Zero;
            }

            return (UIntPtr)currentAddress;
        }
        #endregion

        #region AOB Scanning - Optimized
        public Task<IEnumerable<long>> AoBScan(long start, long end, string search, bool readable = true, 
            bool writable = false, bool executable = false, string file = "")
        {
            return Task.Run(() => PerformAoBScan(start, end, search, readable, writable, executable, file));
        }

        public Task<IEnumerable<long>> AoBScan(string search, bool writable = false, bool executable = false, string file = "")
        {
            return AoBScan(0L, long.MaxValue, search, true, writable, executable, file);
        }

        private IEnumerable<long> PerformAoBScan(long start, long end, string search, bool readable, 
            bool writable, bool executable, string file)
        {
            string pattern = !string.IsNullOrEmpty(file) ? LoadCode(search, file) : search;
            byte[] aobPattern;
            byte[] mask;
            ParseAobPattern(pattern, out aobPattern, out mask);

            SYSTEM_INFO sysInfo;
            GetSystemInfo(out sysInfo);

            UIntPtr minAddress = sysInfo.minimumApplicationAddress;
            UIntPtr maxAddress = sysInfo.maximumApplicationAddress;

            if (start < (long)minAddress.ToUInt64())
                start = (long)minAddress.ToUInt64();
            
            if (end > (long)maxAddress.ToUInt64())
                end = (long)maxAddress.ToUInt64();

            Debug.WriteLine($"[AOB] Scan started: 0x{start:X} - 0x{end:X}");

            var regions = CollectMemoryRegions(start, end, minAddress, maxAddress, readable, writable, executable);
            var results = new ConcurrentBag<long>();

            // Use parallel processing with limited degree to reduce CPU usage
            var options = new ParallelOptions 
            { 
                MaxDegreeOfParallelism = Environment.ProcessorCount / 2 // Use half of available cores
            };

            Parallel.ForEach(regions, options, region =>
            {
                long[] matches = ScanRegion(region, aobPattern, mask);
                foreach (long match in matches)
                {
                    results.Add(match);
                }
            });

            Debug.WriteLine($"[AOB] Scan completed. Found {results.Count} results.");

            return results.OrderBy(x => x);
        }

        private void ParseAobPattern(string pattern, out byte[] aobPattern, out byte[] mask)
        {
            string[] parts = pattern.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            aobPattern = new byte[parts.Length];
            mask = new byte[parts.Length];

            for (int i = 0; i < parts.Length; i++)
            {
                string part = parts[i];

                if (part == "??" || part == "?")
                {
                    mask[i] = 0x00;
                    aobPattern[i] = 0x00;
                }
                else if (part.Length == 2 && part[1] == '?')
                {
                    mask[i] = 0xF0;
                    aobPattern[i] = (byte)(Convert.ToByte(part[0].ToString(), 16) << 4);
                }
                else if (part.Length == 2 && part[0] == '?')
                {
                    mask[i] = 0x0F;
                    aobPattern[i] = Convert.ToByte(part[1].ToString(), 16);
                }
                else
                {
                    mask[i] = 0xFF;
                    aobPattern[i] = Convert.ToByte(part, 16);
                }
            }
        }

        private List<MemoryRegionResult> CollectMemoryRegions(long start, long end, UIntPtr minAddress, 
            UIntPtr maxAddress, bool readable, bool writable, bool executable)
        {
            var regions = new List<MemoryRegionResult>();
            UIntPtr address = new UIntPtr((ulong)start);
            MEMORY_BASIC_INFORMATION memInfo;

            while (VirtualQueryEx(_pHandle, address, out memInfo).ToUInt64() != 0 &&
                   address.ToUInt64() < (ulong)end &&
                   address.ToUInt64() + (ulong)memInfo.RegionSize > address.ToUInt64())
            {
                bool isValid = memInfo.State == 0x1000 && // MEM_COMMIT
                              memInfo.BaseAddress.ToUInt64() < maxAddress.ToUInt64() &&
                              (memInfo.Protect & 0x100) == 0 && // PAGE_GUARD
                              (memInfo.Protect & 0x01) == 0 && // PAGE_NOACCESS
                              (memInfo.Type == MEM_PRIVATE || memInfo.Type == MEM_IMAGE);

                if (isValid)
                {
                    bool read = (memInfo.Protect & 0x02) > 0;
                    bool write = (memInfo.Protect & 0x04) > 0 || (memInfo.Protect & 0x08) > 0 ||
                                (memInfo.Protect & 0x40) > 0 || (memInfo.Protect & 0x80) > 0;
                    bool exec = (memInfo.Protect & 0x10) > 0 || (memInfo.Protect & 0x20) > 0 ||
                               (memInfo.Protect & 0x40) > 0 || (memInfo.Protect & 0x80) > 0;

                    isValid = (read && readable) || (write && writable) || (exec && executable);
                }

                if (isValid)
                {
                    var region = new MemoryRegionResult
                    {
                        CurrentBaseAddress = address,
                        RegionSize = memInfo.RegionSize,
                        RegionBase = memInfo.BaseAddress
                    };

                    // Merge contiguous regions
                    if (regions.Count > 0)
                    {
                        var last = regions[regions.Count - 1];
                        if ((ulong)last.RegionBase + (ulong)last.RegionSize == (ulong)memInfo.BaseAddress)
                        {
                            regions[regions.Count - 1] = new MemoryRegionResult
                            {
                                CurrentBaseAddress = last.CurrentBaseAddress,
                                RegionBase = last.RegionBase,
                                RegionSize = last.RegionSize + memInfo.RegionSize
                            };
                        }
                        else
                        {
                            regions.Add(region);
                        }
                    }
                    else
                    {
                        regions.Add(region);
                    }
                }

                address = new UIntPtr(memInfo.BaseAddress.ToUInt64() + (ulong)memInfo.RegionSize);
            }

            return regions;
        }

        private unsafe long[] ScanRegion(MemoryRegionResult region, byte[] pattern, byte[] mask)
        {
            IntPtr buffer = Marshal.AllocHGlobal((int)region.RegionSize);
            
            try
            {
                ulong bytesRead;
                if (!ReadProcessMemory(_pHandle, region.CurrentBaseAddress, buffer, 
                    (UIntPtr)(ulong)region.RegionSize, out bytesRead))
                {
                    return new long[0];
                }

                var results = new List<long>();
                byte* ptr = (byte*)buffer.ToPointer();
                int offset = -pattern.Length;

                while (true)
                {
                    offset = FindPattern(ptr, (int)bytesRead, pattern, mask, offset + pattern.Length);
                    
                    if (offset < 0)
                        break;

                    results.Add((long)region.CurrentBaseAddress.ToUInt64() + offset);
                }

                return results.ToArray();
            }
            finally
            {
                Marshal.FreeHGlobal(buffer);
            }
        }

        private unsafe int FindPattern(byte* data, int dataLength, byte[] pattern, byte[] mask, int start = 0)
        {
            if (dataLength <= 0 || pattern.Length == 0 || start > dataLength - pattern.Length)
                return -1;

            int maxIndex = dataLength - pattern.Length;

            for (int i = start; i <= maxIndex; i++)
            {
                if ((data[i] & mask[0]) != (pattern[0] & mask[0]))
                    continue;

                bool found = true;
                for (int j = 1; j < pattern.Length; j++)
                {
                    if ((data[i + j] & mask[j]) != (pattern[j] & mask[j]))
                    {
                        found = false;
                        break;
                    }
                }

                if (found)
                    return i;
            }

            return -1;
        }
        #endregion

        #region Memory Protection
        public bool ChangeProtection(string code, MemoryProtection newProtection, 
            out MemoryProtection oldProtection, string file = "")
        {
            UIntPtr address = GetCode(code, file);
            
            if (address == UIntPtr.Zero || _pHandle == IntPtr.Zero)
            {
                oldProtection = 0;
                return false;
            }

            return VirtualProtectEx(_pHandle, address, (IntPtr)(_is64Bit ? 8 : 4), 
                newProtection, out oldProtection);
        }

        public UIntPtr VirtualQueryEx(IntPtr hProcess, UIntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer)
        {
            if (_is64Bit || IntPtr.Size == 8)
            {
                MEMORY_BASIC_INFORMATION64 memInfo64;
                UIntPtr result = Native_VirtualQueryEx(hProcess, lpAddress, out memInfo64, 
                    new UIntPtr((uint)Marshal.SizeOf<MEMORY_BASIC_INFORMATION64>()));

                lpBuffer = new MEMORY_BASIC_INFORMATION
                {
                    BaseAddress = memInfo64.BaseAddress,
                    AllocationBase = memInfo64.AllocationBase,
                    AllocationProtect = memInfo64.AllocationProtect,
                    RegionSize = (long)memInfo64.RegionSize,
                    State = memInfo64.State,
                    Protect = memInfo64.Protect,
                    Type = memInfo64.Type
                };

                return result;
            }
            else
            {
                MEMORY_BASIC_INFORMATION32 memInfo32;
                UIntPtr result = Native_VirtualQueryEx(hProcess, lpAddress, out memInfo32, 
                    new UIntPtr((uint)Marshal.SizeOf<MEMORY_BASIC_INFORMATION32>()));

                lpBuffer = new MEMORY_BASIC_INFORMATION
                {
                    BaseAddress = memInfo32.BaseAddress,
                    AllocationBase = memInfo32.AllocationBase,
                    AllocationProtect = memInfo32.AllocationProtect,
                    RegionSize = memInfo32.RegionSize,
                    State = memInfo32.State,
                    Protect = memInfo32.Protect,
                    Type = memInfo32.Type
                };

                return result;
            }
        }
        #endregion

        #region Utilities
        public string LoadCode(string name, string file)
        {
            if (string.IsNullOrEmpty(file))
                return name;

            var sb = new StringBuilder(1024);
            GetPrivateProfileString("codes", name, "", sb, (uint)sb.Capacity, file);
            return sb.ToString();
        }

        public string MSize()
        {
            return _is64Bit ? "X16" : "X8";
        }

        public static bool IsAdmin()
        {
            using (var identity = WindowsIdentity.GetCurrent())
            {
                var principal = new WindowsPrincipal(identity);
                return principal.IsInRole(WindowsBuiltInRole.Administrator);
            }
        }

        public static void Notify(string message)
        {
            try
            {
                Process.Start(new ProcessStartInfo("cmd.exe", 
                    $"/c start cmd /C \"color b && title Error && echo {message} && timeout /t 5\"")
                {
                    CreateNoWindow = true,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Failed to show notification: {ex.Message}");
            }
        }
        #endregion

        #region Structures and Enums
        [StructLayout(LayoutKind.Sequential)]
        public struct MEMORY_BASIC_INFORMATION32
        {
            public UIntPtr BaseAddress;
            public UIntPtr AllocationBase;
            public uint AllocationProtect;
            public uint RegionSize;
            public uint State;
            public uint Protect;
            public uint Type;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MEMORY_BASIC_INFORMATION64
        {
            public UIntPtr BaseAddress;
            public UIntPtr AllocationBase;
            public uint AllocationProtect;
            public uint __alignment1;
            public ulong RegionSize;
            public uint State;
            public uint Protect;
            public uint Type;
            public uint __alignment2;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MEMORY_BASIC_INFORMATION
        {
            public UIntPtr BaseAddress;
            public UIntPtr AllocationBase;
            public uint AllocationProtect;
            public long RegionSize;
            public uint State;
            public uint Protect;
            public uint Type;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SYSTEM_INFO
        {
            public ushort processorArchitecture;
            private ushort reserved;
            public uint pageSize;
            public UIntPtr minimumApplicationAddress;
            public UIntPtr maximumApplicationAddress;
            public IntPtr activeProcessorMask;
            public uint numberOfProcessors;
            public uint processorType;
            public uint allocationGranularity;
            public ushort processorLevel;
            public ushort processorRevision;
        }

        [Flags]
        public enum MemoryProtection : uint
        {
            NoAccess = 0x01,
            ReadOnly = 0x02,
            ReadWrite = 0x04,
            WriteCopy = 0x08,
            Execute = 0x10,
            ExecuteRead = 0x20,
            ExecuteReadWrite = 0x40,
            ExecuteWriteCopy = 0x80,
            Guard = 0x100,
            NoCache = 0x200,
            WriteCombine = 0x400
        }

        [Flags]
        public enum ThreadAccess
        {
            TERMINATE = 0x0001,
            SUSPEND_RESUME = 0x0002,
            GET_CONTEXT = 0x0008,
            SET_CONTEXT = 0x0010,
            SET_INFORMATION = 0x0020,
            QUERY_INFORMATION = 0x0040,
            SET_THREAD_TOKEN = 0x0080,
            IMPERSONATE = 0x0100,
            DIRECT_IMPERSONATION = 0x0200
        }
        #endregion
    }

    internal struct MemoryRegionResult
    {
        public UIntPtr CurrentBaseAddress { get; set; }
        public long RegionSize { get; set; }
        public UIntPtr RegionBase { get; set; }
    }
}
